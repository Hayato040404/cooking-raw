<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cooking Simulator Re:make</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial; }
        canvas { width: 100%; height: 100%; }
        #startScreen, #helpScreen, #orderScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        #helpScreen, #orderScreen { display: none; }
        #orderList {
            max-height: 70vh;
            overflow-y: auto;
            padding: 10px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            -webkit-overflow-scrolling: touch;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
        }
        #targetInfo {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -60%);
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px;
            border-radius: 3px;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: none;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
        }
        #joystick {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 100px;
            height: 100px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: none;
            touch-action: none;
        }
        #joystickKnob {
            position: absolute;
            width: 40px;
            height: 40px;
            background: white;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }
        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background: white;
        }
        #crosshair::before { width: 2px; height: 20px; left: 9px; }
        #crosshair::after { width: 20px; height: 2px; top: 9px; }
        button {
            padding: 8px 16px;
            margin: 5px;
            font-size: 14px;
            background: #444;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            min-width: 100px;
        }
        button:hover { background: #666; }
    </style>
</head>
<body>
    <div id="startScreen">
        <h1>Cooking Simulator Re:make</h1>
        <button onclick="startGame(true)">Start (Normal Mode)</button>
        <button onclick="startGame(false)">Start (Lite Mode)</button>
        <button onclick="showHelp()">Help</button>
    </div>
    <div id="helpScreen">
        <h1>Help</h1>
        <p><b>æ“ä½œæ–¹æ³•:</b></p>
        <p>PC: WASDã§ç§»å‹•ã€ãƒã‚¦ã‚¹ãƒ‰ãƒ©ãƒƒã‚°ã§è¦–ç‚¹å¤‰æ›´ã€ãƒœã‚¿ãƒ³ã§æ“ä½œ</p>
        <p>ãƒ¢ãƒã‚¤ãƒ«: ã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã§ç§»å‹•ã€ã‚¹ãƒ¯ã‚¤ãƒ—ã§è¦–ç‚¹å¤‰æ›´ã€ãƒœã‚¿ãƒ³ã§æ“ä½œ</p>
        <p><b>èª¿ç†æ–¹æ³•:</b></p>
        <p>1. "Order"ã§é£Ÿæã‚„å™¨å…·ã‚’æ³¨æ–‡ï¼ˆãƒ¢ãƒã‚¤ãƒ«ã¯ã‚¹ãƒ¯ã‚¤ãƒ—ã§ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ï¼‰</p>
        <p>2. "Pick"ã§æ‰‹ã«æŒã¤ã€"Place"ã§ãŠã</p>
        <p>3. åŒ…ä¸ã§åˆ‡ã‚‹: é£Ÿæã«è¿‘ã¥ã‘ã‚‹</p>
        <p>4. ç„¼ã/åŠ ç†±: ãƒ•ãƒ©ã‚¤ãƒ‘ãƒ³ã€ã‚³ãƒ³ãƒ­ã€é›»å­ãƒ¬ãƒ³ã‚¸ã«ç½®ã</p>
        <p>5. æ´—ã†: ã‚·ãƒ³ã‚¯ã«ç½®ã</p>
        <p>6. ç››ã‚Šä»˜ã‘: èª¿ç†å°ã‚„çš¿ã«ç½®ãï¼ˆè‡ªç”±ã«çµ„ã¿åˆã‚ã›ï¼ï¼‰</p>
        <p>7. "Serve"ã§ãŠå®¢ã«å‡ºã™ï¼ˆãƒ¬ã‚·ãƒ”ã§é«˜è©•ä¾¡ã€å¤‰ãªæ–™ç†ã‚‚OKï¼‰</p>
        <p><b>ãƒ¢ãƒ¼ãƒ‰:</b></p>
        <p>Normal: ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã¨ã‚µã‚¦ãƒ³ãƒ‰ã‚ã‚Š</p>
        <p>Lite: ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã¨ã‚µã‚¦ãƒ³ãƒ‰ãªã—ï¼ˆè»½é‡ï¼‰</p>
        <button onclick="hideHelp()">Back</button>
    </div>
    <div id="orderScreen">
        <h1>Order Items</h1>
        <div id="orderList">
            <button onclick="orderIngredient('carrot')">Carrot</button>
            <button onclick="orderIngredient('tomato')">Tomato</button>
            <button onclick="orderIngredient('meat')">Meat</button>
            <button onclick="orderIngredient('potato')">Potato</button>
            <button onclick="orderIngredient('onion')">Onion</button>
            <button onclick="orderIngredient('fish')">Fish</button>
            <button onclick="orderIngredient('cheese')">Cheese</button>
            <button onclick="orderIngredient('bread')">Bread</button>
            <button onclick="orderIngredient('egg')">Egg</button>
            <button onclick="orderIngredient('butter')">Butter</button>
            <button onclick="orderIngredient('salt')">Salt</button>
            <button onclick="orderIngredient('detergent')">Detergent</button>
            <button onclick="orderIngredient('rice')">Rice</button>
            <button onclick="orderIngredient('tofu')">Tofu</button>
            <button onclick="orderIngredient('pasta')">Pasta</button>
            <button onclick="orderIngredient('milk')">Milk</button>
            <button onclick="orderIngredient('sugar')">Sugar</button>
            <button onclick="orderIngredient('oil')">Oil</button>
        </div>
        <button onclick="hideOrder()">Close</button>
    </div>
    <div id="info">Dish: None | Score: N/A</div>
    <div id="targetInfo"></div>
    <div id="controls">
        <button onclick="pickObject()">Pick</button>
        <button onclick="placeObject()">Place</button>
        <button onclick="showOrder()">Order</button>
        <button onclick="serveDish()">Serve</button>
    </div>
    <div id="joystick"><div id="joystickKnob"></div></div>
    <div id="crosshair"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script>
        let gameStarted = false;
        let isNormalMode = true;
        const scene = new THREE.Scene();
        const world = new CANNON.World();
        world.gravity.set(0, -9.82, 0);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.DirectionalLight(0xffffff, 1).position.set(5, 10, 5));
        scene.add(new THREE.AmbientLight(0x404040));

        const ground = new THREE.Mesh(
            new THREE.PlaneGeometry(20, 20),
            new THREE.MeshBasicMaterial({ color: 0x555555 })
        );
        ground.rotation.x = -Math.PI / 2;
        scene.add(ground);
        const groundBody = new CANNON.Body({ mass: 0 });
        groundBody.addShape(new CANNON.Plane());
        groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
        world.addBody(groundBody);

        // ã‚­ãƒƒãƒãƒ³ç’°å¢ƒ
        const wallGeo = new THREE.PlaneGeometry(20, 10);
        const wallMat = new THREE.MeshBasicMaterial({ color: 0xF5F5F5 });
        const backWall = new THREE.Mesh(wallGeo, wallMat);
        backWall.position.set(0, 5, -10);
        scene.add(backWall);
        const sideWall = new THREE.Mesh(wallGeo, wallMat);
        sideWall.position.set(-10, 5, 0);
        sideWall.rotation.y = Math.PI / 2;
        scene.add(sideWall);

        const shelfGeo = new THREE.BoxGeometry(10, 0.5, 1);
        const shelfMat = new THREE.MeshBasicMaterial({ color: 0x8B4513 });
        const shelf = new THREE.Mesh(shelfGeo, shelfMat);
        shelf.position.set(0, 3, -9);
        scene.add(shelf);

        const objects = [];
        let dish = "None";
        let heldObject = null;
        let score = "N/A";
        let plateContents = [];

        const blockTypes = {
            carrot: { size: [1, 0.5, 0.5], name: "ãƒ‹ãƒ³ã‚¸ãƒ³", color: 0xFFA500 },
            tomato: { size: [0.8, 0.8, 0.8], name: "ãƒˆãƒãƒˆ", emoji: "ğŸ…" }, // çµµæ–‡å­—é©ç”¨
            meat: { size: [1, 0.3, 1], name: "è‚‰", color: 0x8B4513 },
            potato: { size: [0.7, 0.7, 0.7], name: "ã‚¸ãƒ£ã‚¬ã‚¤ãƒ¢", color: 0xD2B48C },
            onion: { size: [0.9, 0.9, 0.6], name: "ã‚¿ãƒãƒã‚®", color: 0xF5F5DC },
            fish: { size: [1.2, 0.4, 0.6], name: "é­š", color: 0x4682B4 },
            cheese: { size: [0.8, 0.2, 0.8], name: "ãƒãƒ¼ã‚º", color: 0xFFFF00 },
            bread: { size: [1, 0.4, 0.6], name: "ãƒ‘ãƒ³", color: 0xDAA520 },
            egg: { size: [0.5, 0.6, 0.5], name: "åµ", color: 0xFFFACD },
            butter: { size: [0.4, 0.2, 0.4], name: "ãƒã‚¿ãƒ¼", color: 0xFFD700 },
            salt: { size: [0.3, 0.3, 0.3], name: "å¡©", color: 0xFFFFFF },
            detergent: { size: [0.6, 0.8, 0.6], name: "æ´—å‰¤", color: 0x00FFFF },
            rice: { size: [0.7, 0.3, 0.7], name: "ç±³", color: 0xF8F8FF },
            tofu: { size: [0.6, 0.6, 0.6], name: "è±†è…", color: 0xF0EDE5 },
            pasta: { size: [1, 0.2, 0.4], name: "ãƒ‘ã‚¹ã‚¿", color: 0xF5DEB3 },
            milk: { size: [0.5, 1, 0.5], name: "ç‰›ä¹³", color: 0xFFFFFF },
            sugar: { size: [0.4, 0.4, 0.4], name: "ç ‚ç³–", color: 0xFFF8DC },
            oil: { size: [0.6, 0.8, 0.6], name: "æ²¹", color: 0xFFD700 },
            knife: { size: [0.2, 0.1, 1], name: "åŒ…ä¸", color: 0xCCCCCC },
            pan: { size: [2, 0.2, 2], name: "ãƒ•ãƒ©ã‚¤ãƒ‘ãƒ³", color: 0x666666 },
            stove: { size: [2, 0.5, 2], name: "ã‚³ãƒ³ãƒ­", color: 0x333333 },
            microwave: { size: [1.5, 1, 1.5], name: "é›»å­ãƒ¬ãƒ³ã‚¸", color: 0xAAAAAA },
            sink: { size: [2, 0.5, 1], name: "ã‚·ãƒ³ã‚¯", color: 0xB0C4DE },
            counter: { size: [3, 0.5, 1.5], name: "èª¿ç†å°", color: 0x8B5A2B },
            plate: { size: [1.5, 0.1, 1.5], name: "çš¿", color: 0xFFFFFF }
        };
        

        function addObject(x, y, z, type, mass = 1) {
            const { size, name, color, emoji } = blockTypes[type];
            let mesh;

            if (emoji) {
                // çµµæ–‡å­—ã‚’2Dã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã¨ã—ã¦é©ç”¨
                const canvas = document.createElement('canvas');
                canvas.width = 128;
                canvas.height = 128;
                const ctx = canvas.getContext('2d');
                ctx.font = '100px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(emoji, 64, 64);
                const texture = new THREE.CanvasTexture(canvas);
                mesh = new THREE.Sprite(
                    new THREE.SpriteMaterial({ map: texture })
                );
                mesh.scale.set(size[0], size[1], 1);
            } else {
                mesh = new THREE.Mesh(
                    new THREE.BoxGeometry(...size),
                    new THREE.MeshBasicMaterial({ color: color || 0xFFFFFF })
                );
            }
            mesh.position.set(x, y, z);
            scene.add(mesh);

            const body = new CANNON.Body({ mass });
            body.addShape(new CANNON.Box(new CANNON.Vec3(size[0]/2, size[1]/2, size[2]/2)));
            body.position.set(x, y, z);
            world.addBody(body);

            objects.push({ mesh, body, type, state: 'raw', name });
        }

        function sliceObject(obj) {
            const { size } = blockTypes[obj.type];
            const newSize = [size[0]/2, size[1], size[2]];
            const pos = obj.body.position.clone();
            scene.remove(obj.mesh);
            world.remove(obj.body);

            const index = objects.indexOf(obj);
            objects.splice(index, 1);

            addObject(pos.x - size[0]/4, pos.y, pos.z, obj.type, 0.5);
            addObject(pos.x + size[0]/4, pos.y, pos.z, obj.type, 0.5);
            objects.forEach(o => {
                if (o.type === obj.type && o.body.position.distanceTo(pos) < 1) o.state = 'cut';
            });

            if (isNormalMode) {
                addParticleEffect(pos, 0xFFFFFF, 10);
                playSound('cut');
            }
        }

        function initScene() {
            addObject(2, 2, 0, 'knife');
            addObject(-2, 0.5, 0, 'pan', 0);
            addObject(-4, 0.5, 2, 'stove', 0);
            addObject(0, 0.5, 4, 'microwave', 0);
            addObject(4, 0.5, -2, 'sink', 0);
            addObject(0, 0.5, -4, 'counter', 0);
            addObject(-4, 0.5, -2, 'plate', 0);
        }

        // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼ˆè»½é‡åŒ–ãƒ¢ãƒ¼ãƒ‰ã§ç„¡åŠ¹åŒ–å¯èƒ½ï¼‰
        function addParticleEffect(position, color, count) {
            if (!isNormalMode) return;
            const particles = new THREE.Group();
            for (let i = 0; i < count; i++) {
                const particle = new THREE.Mesh(
                    new THREE.SphereGeometry(0.05, 8, 8),
                    new THREE.MeshBasicMaterial({ color })
                );
                particle.position.set(
                    position.x + (Math.random() - 0.5) * 0.5,
                    position.y + (Math.random() - 0.5) * 0.5,
                    position.z + (Math.random() - 0.5) * 0.5
                );
                particles.add(particle);
            }
            scene.add(particles);
            setTimeout(() => scene.remove(particles), 500);
        }

        // ã‚µã‚¦ãƒ³ãƒ‰ï¼ˆè»½é‡åŒ–ãƒ¢ãƒ¼ãƒ‰ã§ç„¡åŠ¹åŒ–å¯èƒ½ï¼‰
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const sounds = {
            cut: new Audio('https://www.soundjay.com/buttons/sounds/button-1.mp3'),
            cook: new Audio('https://www.soundjay.com/mechanical/sounds/frying-pan-1.mp3'),
            wash: new Audio('https://www.soundjay.com/nature/sounds/water-splash-1.mp3'),
            ambient: new Audio('https://www.soundjay.com/ambient/sounds/kitchen-ambience-1.mp3')
        };
        sounds.ambient.loop = true;
        function playSound(type) {
            if (!isNormalMode) return;
            sounds[type].currentTime = 0;
            sounds[type].play();
        }

        camera.position.set(0, 5, 10);
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let yaw = 0, pitch = 0, moveSpeed = 0.1, isDragging = false, previousTouch = null;
        const raycaster = new THREE.Raycaster();

        const joystick = document.getElementById('joystick');
        const knob = document.getElementById('joystickKnob');
        let joystickActive = false, joystickOrigin = { x: 0, y: 0 };

        joystick.addEventListener('touchstart', (e) => {
            joystickActive = true;
            const touch = e.touches[0];
            joystickOrigin = { x: touch.clientX, y: touch.clientY };
        });

        joystick.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (joystickActive) {
                const touch = e.touches[0];
                const dx = (touch.clientX - joystickOrigin.x) / 50;
                const dz = (touch.clientY - joystickOrigin.y) / 50;
                knob.style.left = `${50 + dx * 30}%`;
                knob.style.top = `${50 + dz * 30}%`;

                const direction = new THREE.Vector3();
                camera.getWorldDirection(direction);
                direction.y = 0;
                direction.normalize();

                const right = new THREE.Vector3().crossVectors(direction, new THREE.Vector3(0, 1, 0));
                camera.position.addScaledVector(direction, -dz * moveSpeed);
                camera.position.addScaledVector(right, dx * moveSpeed);
            }
        }, { passive: false });

        joystick.addEventListener('touchend', () => {
            joystickActive = false;
            knob.style.left = '50%';
            knob.style.top = '50%';
        });

        function pickObject() {
            if (!gameStarted) return;
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            raycaster.set(camera.position, direction);
            const intersects = raycaster.intersectObjects(objects.map(o => o.mesh));
            if (intersects.length > 0) {
                heldObject = objects.find(o => o.mesh === intersects[0].object);
                heldObject.body.mass = 0;
                heldObject.body.velocity.set(0, 0, 0);
            }
        }

        function placeObject() {
            if (!gameStarted || !heldObject) return;
            heldObject.body.mass = 1;
            heldObject = null;
        }

        function orderIngredient(type) {
            if (!gameStarted) return;
            const pos = camera.position.clone().add(new THREE.Vector3(0, 2, -2));
            addObject(pos.x, pos.y, pos.z, type);
            hideOrder();
        }

        const recipes = {
            "Fried Rice": ["rice_cooked", "egg_cooked", "salt"],
            "Spaghetti": ["pasta_cooked", "tomato_cooked", "salt"],
            "Grilled Fish": ["fish_cooked", "salt"],
            "Cheese Sandwich": ["bread", "cheese"],
            "Mashed Potato": ["potato_cooked", "butter"],
            "Omelette": ["egg_cooked", "salt"],
            "Tofu Soup": ["tofu_washed", "salt"],
            "Carrot Cake": ["carrot_cooked", "sugar", "egg"],
            "Detergent Disaster": ["detergent"]
        };

        function serveDish() {
            if (plateContents.length === 0) return;
            let dishName = "è¬ã®æ–™ç†";
            let baseScore = 0;

            const contentsTypes = plateContents.map(item => item.type + (item.state !== 'raw' ? `_${item.state}` : ''));
            for (const [name, ingredients] of Object.entries(recipes)) {
                if (ingredients.every(ing => contentsTypes.includes(ing))) {
                    dishName = name;
                    baseScore = 4;
                    break;
                }
            }

            if (dishName === "è¬ã®æ–™ç†") {
                baseScore = contentsTypes.includes('detergent') ? 1 : Math.min(3, plateContents.length);
                dishName = contentsTypes.length > 1 ? "å¥‡æŠœãªå‰µä½œæ–™ç†" : "ã‚·ãƒ³ãƒ—ãƒ«ãªä¸€å“";
            }
            score = Math.max(1, Math.min(5, Math.floor(baseScore + Math.random() * 2)));
            alert(`æ–™ç†: ${dishName}\nãŠå®¢ã•ã‚“ã®è©•ä¾¡: ${score}/5`);
            dish = "None";
            plateContents = [];
            updateInfo();
        }

        function checkCooking() {
            if (heldObject && heldObject.type === 'knife') {
                objects.forEach(obj => {
                    if (['carrot', 'tomato', 'meat', 'potato', 'onion', 'fish', 'egg'].includes(obj.type) &&
                        obj.body.position.distanceTo(heldObject.body.position) < 1.5 && obj.state === 'raw') {
                        sliceObject(obj);
                    }
                });
            }

            objects.forEach(obj => {
                const pan = objects.find(o => o.type === 'pan');
                const stove = objects.find(o => o.type === 'stove');
                const microwave = objects.find(o => o.type === 'microwave');
                const sink = objects.find(o => o.type === 'sink');
                const counter = objects.find(o => o.type === 'counter');
                const plate = objects.find(o => o.type === 'plate');

                if ((pan || stove) && ['cut', 'raw'].includes(obj.state) && 
                    (obj.body.position.distanceTo(pan?.body.position || stove.body.position) < 1.5)) {
                    obj.mesh.material.color.set(0x8B4513);
                    obj.state = 'cooked';
                    if (isNormalMode) {
                        addParticleEffect(obj.body.position, 0xFFA500, 10);
                        playSound('cook');
                    }
                }
                if (microwave && ['cut', 'raw'].includes(obj.state) && 
                    obj.body.position.distanceTo(microwave.body.position) < 1.5) {
                    obj.mesh.material.color.set(0xCD853F);
                    obj.state = 'cooked';
                    if (isNormalMode) {
                        addParticleEffect(obj.body.position, 0xFFFF00, 5);
                    }
                }
                if (sink && obj.body.position.distanceTo(sink.body.position) < 1.5) {
                    obj.mesh.material.color.set(0xADD8E6);
                    obj.state = 'washed';
                    if (isNormalMode) {
                        addParticleEffect(obj.body.position, 0x00FFFF, 15);
                        playSound('wash');
                    }
                }
                if ((counter || plate) && obj.body.position.distanceTo((counter || plate).body.position) < 1.5 && !plateContents.includes(obj)) {
                    plateContents.push(obj);
                    if (obj.type !== 'counter' && obj.type !== 'plate') {
                        dish = "æº–å‚™ä¸­";
                        updateInfo();
                    }
                }
            });
        }

        function updateInfo() {
            document.getElementById('info').textContent = `Dish: ${dish} | Score: ${score} | Mode: ${isNormalMode ? 'Normal' : 'Lite'}`;
        }

        document.addEventListener('keydown', (e) => {
            if (!gameStarted) return;
            switch (e.key) {
                case 'w': moveForward = true; break;
                case 's': moveBackward = true; break;
                case 'a': moveLeft = true; break;
                case 'd': moveRight = true; break;
            }
        });
        document.addEventListener('keyup', (e) => {
            switch (e.key) {
                case 'w': moveForward = false; break;
                case 's': moveBackward = false; break;
                case 'a': moveLeft = false; break;
                case 'd': moveRight = false; break;
            }
        });

        document.addEventListener('mousedown', (e) => {
            if (!gameStarted) return;
            isDragging = true;
        });
        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                yaw -= (e.movementX * 0.002);
                pitch -= (e.movementY * 0.002);
                pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
            }
        });
        document.addEventListener('mouseup', () => isDragging = false);

        document.addEventListener('touchstart', (e) => {
            if (!gameStarted) return;
            isDragging = true;
            previousTouch = e.touches[0];
        });
        document.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (isDragging && previousTouch) {
                const touch = e.touches[0];
                const deltaX = touch.clientX - previousTouch.clientX;
                const deltaY = touch.clientY - previousTouch.clientY;
                yaw -= deltaX * 0.005;
                pitch -= deltaY * 0.005;
                pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
                previousTouch = touch;
            }
        }, { passive: false });
        document.addEventListener('touchend', () => {
            isDragging = false;
            previousTouch = null;
        });

        function animate() {
            requestAnimationFrame(animate);
            if (!gameStarted) return;

            world.step(1 / 60);

            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            direction.y = 0;
            direction.normalize();

            if (moveForward) camera.position.addScaledVector(direction, moveSpeed);
            if (moveBackward) camera.position.addScaledVector(direction, -moveSpeed);
            if (moveLeft) camera.position.addScaledVector(new THREE.Vector3().crossVectors(direction, new THREE.Vector3(0, 1, 0)), -moveSpeed);
            if (moveRight) camera.position.addScaledVector(new THREE.Vector3().crossVectors(direction, new THREE.Vector3(0, 1, 0)), moveSpeed);

            camera.rotation.order = 'YXZ';
            camera.rotation.y = yaw;
            camera.rotation.x = pitch;

            if (heldObject) {
                const holdPos = camera.position.clone().add(direction.multiplyScalar(2));
                heldObject.body.position.set(holdPos.x, holdPos.y, holdPos.z);
            }

            objects.forEach(obj => {
                obj.mesh.position.copy(obj.body.position);
                obj.mesh.quaternion.copy(obj.body.quaternion);
            });

            raycaster.set(camera.position, camera.getWorldDirection(new THREE.Vector3()));
            const intersects = raycaster.intersectObjects(objects.map(o => o.mesh));
            if (intersects.length > 0) {
                const target = objects.find(o => o.mesh === intersects[0].object);
                document.getElementById('targetInfo').textContent = `${target.name} (${target.state})`;
            } else {
                document.getElementById('targetInfo').textContent = "";
            }

            checkCooking();
            renderer.render(scene, camera);
        }
        animate();

        function startGame(normalMode) {
            isNormalMode = normalMode;
            gameStarted = true;
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('controls').style.display = 'block';
            joystick.style.display = 'block';
            initScene();
            if (isNormalMode) sounds.ambient.play();
            updateInfo();
        }

        function showHelp() {
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('helpScreen').style.display = 'flex';
        }

        function hideHelp() {
            document.getElementById('helpScreen').style.display = 'none';
            document.getElementById('startScreen').style.display = 'flex';
        }

        function showOrder() {
            document.getElementById('orderScreen').style.display = 'flex';
        }

        function hideOrder() {
            document.getElementById('orderScreen').style.display = 'none';
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
